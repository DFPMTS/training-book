#import "/book.typ": book-page
#import "@preview/showybox:2.0.4": showybox

#show: book-page.with(title: "初识A阶段")

= 初识A阶段

以下内容主要来自#link("https://ysyx.oscc.cc/docs/2306/advanced/advanced.html")[第六期一生一芯的A阶段大纲]

== PA Continued

// (todo: 设计一个小的作业，实现这个破坏)
在之前的阶段，我们的程序都直接运行在物理内存上，地址“所见即所得”。但这在现代操作系统中是非常危险的。想象一下，多个程序同时运行时，A程序的内存错误可能会轻易地摧毁B程序，甚至整个系统。

虚拟内存（Virtual Memory） 就是解决这个问题的“魔法”。PA3和PA4.2的核心，就是让你亲手实现这种魔法。你将构建SV32页表机制，它就像一个地址翻译官，把程序看到的、各自独立的“虚拟地址”翻译成真正的“物理地址”。

通过这个过程，每个程序都以为自己独占了整个内存空间，从而被安全地隔离开。这不仅带来了安全性，还使得我们可以使用比物理内存更大的地址空间，甚至实现写时复制(Copy On Write, COW)等高级功能。

完成 PA3 与 PA4.2。

选做题：并发执行多个用户进程。

目标：理解SV32页表 & 学习OS基本知识。

== M-extension

乘法器与除法器设计。

我们此前的NPC严格遵守RV32E指令集，这意味着它的硬件逻辑中，根本不存在处理乘法和除法的单元。然而，当我们在C代码中写下 `a * b` 或 `c / d` 时，程序却能正确执行，仿佛一切都理所当然。答案藏在编译器和运行时环境（AM）的“魔术”里：编译器将这些高级语言操作，链接到了抽象机（AM）中提供的软件实现函数。

请你尝试在AM中找出对应的软件实现函数，并结合反汇编工具，完整地追踪一行C代码（例如 `c = a * b`）从编译、链接到最终在你的NPC上执行的全过程。亲眼见证，编译器是如何将一个简单的 `*` 运算符，巧妙地替换成一个对软件函数的 `call` 指令。

当你完成上述任务后，你会深刻理解：所谓的“软实现”，本质上是用一连串基础的加、减、移位指令，去笨拙地模拟乘除法。这就像让一辆马车去和跑车竞速——虽然最终都能到达终点，但效率有天壤之别。硬件执行一条乘法指令可能只需几个周期，而软件模拟则动辄需要成百上千个周期。这对于任何需要密集计算的场景（如图形处理、科学模拟、AI推理等），这种性能瓶颈都是不能接受的。

现在，你的角色将从软件的“使用者”转变为硬件的“创造者”。你不能再简单地调用一个 `*` 或 `/` 运算符，而是需要深入到逻辑门和时序电路，在你的NPC中亲手设计并实现乘法器与除法器。我们建议你首先实现*流水化Radix-4 Booth乘法器*与*恢复余数的除法器*。

目标：理解功能单元设计。

思考题：
- 你应该如何量化从“软件模拟”升级到“硬件实现”所带来的性能提升？
- 除法器通常是处理器中延迟最高的单元之一。投入更多资源去优化它的延迟（例如从32周期优化到16周期），会对哪些类型的程序产生显著影响？如何进行定量分析？

参考资料：

- #link("https://ysyx.oscc.cc/slides/2205/20.html")[第五期课件：功能单元设计]

- #link(
    "https://github.com/MaZirui2001/cs-teaching/blob/main/Computer-Organization-and-Design/Advanced/%E4%B9%98%E6%B3%95%E5%99%A8%E4%B8%8E%E9%99%A4%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1.pdf",
  )[MaZirui2001: 乘法器与除法器的设计]

== 改造NPC

在NPC上实现

- RV32E -> RV32I

- M-extension

- Virtual Memory

并运行支持虚存管理的Nanos-lite

在实现SV32页表的过程中，尽量：（1）参数化 （2）模块化，以便后续复用。

！（你理解细节的）应用程序是宝贵的验证资源。

= ISA

== 热身活动

RISC-V ISA的学习将伴随着我们扩展NEMU功能的过程。后续我们会有针对性的学习，现在只需要完成热身活动即可。

请阅读手册，找出以下问题的答案：

+ `sstatus`和`mstatus`寄存器的关系是什么？

+ 在什么情况下，一条 `jal` / `jalr` 指令应当对RAS (Return Address Stack) 进行一次Push / Pop? （Hint：在实现ftrace时，就已经遇到过这个问题了）

+ `Instruction Address Misaligned` 异常是由哪条指令触发的？ C扩展的加入对这个异常有什么影响？
